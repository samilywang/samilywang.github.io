---
layout: post
title: Promise A+的一个简单实现及思考
desc: 一步步根据官方Promise A+规范实现一个Promise，并且能通过所有官方测试用例。
date: 2021-12-13 18:27:00 +0800
tags: JavaScript
---

（警告！本文很长，特别长，极其的长...）

（警告！本文很长，特别长，极其的长...）

（警告！本文很长，特别长，极其的长...）

# Promises/A+

[Promises/A+文档](https://promisesaplus.com/)

# 完整代码

[完整代码仓库地址](https://github.com/samilywang/playground/tree/master/promise)

# 开始根据文档编写(Typescript)

## Part 1 Terminology

<blockquote>
  1. Terminology
  <ol style="list-style: none;">
    <li>1.1 “promise” is an object or function with a then method whose behavior conforms to this specification.</li>
    <li>1.2 “thenable” is an object or function that defines a then method.</li>
    <li>1.3 “value” is any legal JavaScript value (including undefined, a thenable, or a promise).</li>
    <li>1.4 “exception” is a value that is thrown using the throw statement.</li>
    <li>1.5 “reason” is a value that indicates why a promise was rejected.</li>
  </ol>
</blockquote>

翻译成代码，简单地定义了一个接口`Thenable`及对应的一个实现类`SimplePromise`

```typescript
// thenable接口
+ export interface Thenable {
+   then: Function;
+ }

+ export class SimplePromise implements Thenable {
+   then() {}
+ }
```

## Part 2 Requirements

### 2.1 Promise States

<blockquote>
	2.1 Promise States <br />
	A promise must be in one of three states: pending, fulfilled, or rejected.
	<ol style="list-style: none">
		<li>
			2.1.1 When pending, a promise:
			<ol style="list-style:none">
				<li>2.1.1.1 a promise: may transition to either the fulfilled or rejected state. </li>
			</ol>
		</li>
		<li>
			2.1.2 When fulfilled, a promise:
			<ol style="list-style:none">
				<li>2.1.2.1 must not transition to any other state. </li>
				<li>2.1.2.2 must have a value, which must not change. </li>
			</ol>
		</li>
		<li>
			2.1.3 When rejected, a promise:
			<ol style="list-style:none">
				<li>2.1.3.1 must not transition to any other state. </li>
				<li>2.1.3.2 must have a reason, which must not change.</li>
			</ol>
		</li>
	</ol>
	Here, “must not change” means immutable identity (i.e. ===), but does not imply deep immutability.
</blockquote>

翻译成代码，新增了一个`Promise`状态的枚举，以及`SimplePromise`中的三个字段：记录当前状态的字段`state`、成功时的值`value`、失败时的原因`reason`

```typescript
// thenable接口
export interface Thenable {
  then: Function;
}

// Promise的三种状态
+ enum SimplePromiseState {
+ pending,
+ fulfilled,
+ rejected,
+}

export class SimplePromise implements Thenable {
+ state: SimplePromiseState;
+ value: unknown;
+ reason: unknown;

  then() {}
}
```

然后可以思考一下构造函数`constructor`，我们一般新建一个`Promise`，都是这样调用的：

```typescript
const aPromise = new Promise((resolve, reject) => {
  // do something...

  if (success) {
    resolve(value);
  } else {
    reject(resaon);
  }
});
```

所以这边`constructor`也是接受这样一个以`resolve`, `reject`回调函数为参数的函数`executor`

```typescript
+ type ResolveFunc = (value: unknown) => void;
+ type RejectFunc = (reason: unknown) => void;

export class SimplePromise implements Thenable {
  ...
+ constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => {}) {
+   ...
+ }
  ...
}
```

然后根据这个构造函数的定义以及规范中`Promise`状态转换的规定，可以基本完成`constructor`函数的实现

```typescript
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;

  // Promise A+规范对于构造函数这一块没有明确规定，这边按照常规的ES6+的用法来设计
+ constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => {}) {
+   // 初始化内部状态为pending
+   this.state = SimplePromiseState.pending;
+
+   const resolve = (value: unknown) => {
+     if (this.state === SimplePromiseState.pending) {
+       this.state = SimplePromiseState.fulfilled;
+       this.value = value;
+     }
+     // 这边如果resolve的时候promise不是pending状态其实可以报个错，但是不报也不影响
+   };
+   const reject = (reason: unknown) => {
+     if (this.state === SimplePromiseState.pending) {
+       this.state = SimplePromiseState.rejected;
+       this.reason = reason;
+     }
+     // 这边如果reject的时候promise不是pending状态其实可以报个错，但是不报也不影响
+   };
+
+   try {
+     executor(resolve, reject);
+   } catch (e) {
+     reject(e);
+   }
+ }
  ...
}
```

`constructor`内部的代码大致可以分为

1. 初始化`Promise`内部的状态为`pending`
2. 提供`resolve`, `reject`函数
   1. `resolve`：将`Promise`的状态从`pending`转换为`fulfilled`，并记录`value`
   2. `reject`：将`Promise`的状态从`pending`转换为`rejected`，并记录`reason`
3. 执行`executor`
4. 如果有捕捉到`error`，直接以`error`作为参数执行`reject`

### 2.2 The Then Method

<blockquote>
	2.2 The Then Method<br/>
	A promise must provide a then method to access its current or eventual value or reason.<br/>
	A promise’s then method accepts two arguments:<br/>
	<code>promise.then(onFulfilled, onRejected)</code>
	<ol style="list-style: none">
		<li>
			 2.2.1 Both onFulfilled and onRejected are optional arguments:
			<ol style="list-style: none">
				<li>2.2.1.1 If onFulfilled is not a function, it must be ignored.</li>
				<li>2.2.1.2 If onRejected is not a function, it must be ignored.</li>
			</ol>
		</li>
		<li>
			 2.2.2 If onFulfilled is a function:
			<ol style="list-style: none">
				<li>2.2.2.1 it must be called after promise is fulfilled, with promise’s value as its first argument.</li>
				<li>2.2.2.2 it must not be called before promise is fulfilled.</li>
				<li>2.2.2.3 it must not be called more than once.</li>
			</ol>
		</li>
		<li>
			 2.2.3 If onRejected is a function,
			<ol style="list-style: none">
				<li>2.2.3.1 it must be called after promise is rejected, with promise’s reason as its first argument.</li>
				<li>2.2.3.2 it must not be called before promise is rejected.</li>
				<li>2.2.3.3 it must not be called more than once.</li>
			</ol>
		</li>
		<li>
			 2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code.
		</li>
		<li>
			 2.2.5 onFulfilled and onRejected must be called as functions (i.e. with no this value).
		</li>
		<li>
			 2.2.6 then may be called multiple times on the same promise.
			<ol style="list-style: none">
				<li>2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.</li>
				<li>2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.</li>
			</ol>
		</li>
		<li>
			 2.2.7 then must return a promise. <br/>
			<code>promise2 = promise1.then(onFulfilled, onRejected);</code>
			<ol style="list-style: none">
				<li>2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</li>
				<li>2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</li>
				<li>2.2.7.3 If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.</li>
				<li>2.2.7.4  If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1.</li>
			</ol>
		</li>
	</ol>
</blockquote>

这边就是`Promise A+`规范对于`.then`方法的规定，继续用代码翻译。

首先是对`then`函数入参和出参的定义

入参：`onFulfilled`， `onRejected`，均为可选参数，类型应为接受 Promise 当前或未来的`value/reason`为参数的回调函数。如果这两者的类型并不是函数，则忽略之。

出参：返回一个`Promise`，形成链式调用（这一步很重要，但也比较复杂）

```typescript
// 一些函数类型的定义
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;
+ type OnFulfilledCallback = (value: unknown) => unknown;
+ type OnRejectedCallback = (reason: unknown) => unknown;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;

  constructor() {...}

+ then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
+   // todo:
+ }
}
```

其次，规范规定`onFulfilled/onRejected`必须在`Promise`内部的状态变成`fulfilled/rejected`后才能回调（且至多只能调用一次）。运行`then`函数的时候，`promise`的状态仍然可能处于`pending`，所以我们必须在`promise`内部保存`onFulfilled/onRejected`这两个函数，以便于在`pending` 转换为`fulfilled/rejected`时再调用。

```typescript
// 一些函数类型的定义
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;
type OnFulfilledCallback = (value: unknown) => unknown;
type OnRejectedCallback = (reason: unknown) => unknown;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
+ onFulfilledCallback: OnFulfilledCallback;
+ onRejectedCallback: OnRejectedCallback;

  constructor() {...}

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
    // todo:
  }
}
```

如果`then`函数只能调用一次，上述的设计是可行的。但是规范中明确说明，`then`函数可以被调用多次，所以我们需要将`onFulfilledCallback/onRejectedCallback`改为数组（字段名加一个`s`表示多个），并且在构造函数中进行初始化。

```typescript
// 一些函数类型的定义
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;
type OnFulfilledCallback = (value: unknown) => unknown;
type OnRejectedCallback = (reason: unknown) => unknown;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
+ onFulfilledCallbacks: OnFulfilledCallback[];
+ onRejectedCallbacks: OnRejectedCallback[];

  constructor() {
    this.state = SimplePromiseState.pending;
+   this.onFulfilledCallbacks = [];
+   this.onRejectedCallbacks = [];
    ...
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
    // todo:
  }
}
```

我们再回到`then`函数本身，可以很简单地推导出如下代码，根据当前`promise`状态进行不同的处理。

1. `pending`：将`onFulfilled`，`onRejected`加入到回调函数数组中
2. `fulfilled`：以`value`作为第一个参数调用`onFulfilled`
3. `rejected`：以`reason`作为第一个参数调用`onRejected`

```typescript
// 一些函数类型的定义
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;
type OnFulfilledCallback = (value: unknown) => unknown;
type OnRejectedCallback = (reason: unknown) => unknown;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
  onFulfilledCallbacks: OnFulfilledCallback[];
  onRejectedCallbacks: OnRejectedCallback[];

  constructor() {
    ...
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
+   switch (this.state) {
+     case SimplePromiseState.pending:
+       if (typeof onFulfilled === 'function') {
+         this.onFulfilledCallbacks.push(onFulfilled);
+       }
+       if (typeof onRejected === 'function') {
+         this.onRejectedCallbacks.push(onRejected);
+       }
+       break;
+     case SimplePromiseState.fulfilled:
+       if (typeof onFulfilled === 'function') {
+         onFulfilled(this.value);
+       }
+       break;
+     case SimplePromiseState.rejected:
+       if (typeof onRejected === 'function') {
+         onRejected.(this.reason);
+       }
+       break;
+   }
	  ...
  }
}
```

> onFulfilled or onRejected must not be called until the execution context stack contains only platform code.

规范中规定，`then`注册的`onFulfilled/onRejected`的调用时机必须是当前的上下文执行栈只剩下平台代码之后。
这句话比较难以理解，规范在后面的`Notes`部分也给出了更加详细的解释：

> Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.

这边需要先了解一下 JavaScript 的[事件循环机制](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)。
然后简单总结一下要求，就是`onFulfilled/onRejected`必须是异步执行的，并且必须在`promise`的状态转换为`fulfilled/rejected`之后。

- 何时`promise`会从`pending`转换为`fulfilled/rejected`？调用构造函数中提供的`resolve/reject`函数时。所以需要在`resolve/reject`函数中去执行保存的`onFulfilledCallbacks/onRejectedCallbacks`
- `onFulfilled/onRejected`如何异步执行？这边采用了最简单的`setTimeout`来改造

so, show the code~

```typescript
// Thenable接口
export interface Thenable {
  then: Function;
}

// Promise的三种状态
enum SimplePromiseState {
  pending,
  fulfilled,
  rejected,
}

// 一些函数类型的定义
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;
type OnFulfilledCallback = (value: unknown) => unknown;
type OnRejectedCallback = (reason: unknown) => unknown;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
  onFulfilledCallbacks: OnFulfilledCallback[];
  onRejectedCallbacks: OnRejectedCallback[];

  // Promise A+规范对于构造函数这一块没有明确规定，这边按照常规的ES6+的用法来设计
  constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => {}) {
    // 初始化内部状态为pending
    this.state = SimplePromiseState.pending;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value: unknown) => {
      if (this.state === SimplePromiseState.pending) {
        this.state = SimplePromiseState.fulfilled;
        this.value = value;
+       this.onFulfilledCallbacks.forEach(callback => callback(value));
      }
      // 这边如果resolve的时候promise不是pending状态其实可以报个错，但是不报也不影响
    };
    const reject = (reason: unknown) => {
      if (this.state === SimplePromiseState.pending) {
        this.state = SimplePromiseState.rejected;
        this.reason = reason;
+       this.onRejectedCallbacks.forEach(callback => callback(reason));
      }
      // 这边如果reject的时候promise不是pending状态其实可以报个错，但是不报也不影响
    };

    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
+   // 将onFulfilled/onRejected改造为异步函数
+   const asyncOnFulfilled = (value: unknown) => {
+     setTimeout(() => {
+       if (typeof onFulfilled === 'function') {
+         onFulfilled(value);
+       }
+     });
+   };
+   const asyncOnRejected = (reason: unknown) => {
+     setTimeout(() => {
+       if (typeof onRejected === 'function') {
+         onRejected(reason);
+       }
+     });
+   };
+
+   // 根据promise状态进行处理
+   switch (this.state) {
+     case SimplePromiseState.pending:
+       this.onFulfilledCallbacks.push(asyncOnFulfilled);
+       this.onRejectedCallbacks.push(asyncOnRejected);
+       break;
+     case SimplePromiseState.fulfilled:
+       asyncOnFulfilled(this.value);
+       break;
+     case SimplePromiseState.rejected:
+       asyncOnRejected(this.reason);
+       break;
+   }
    ...
  }
}
```

好了，到目前为止，除了最后一个`then`需要返回一个`promise`的要求，其他的规范都已经实现了。最后再来关注`then`返回一个`promise`的这一条规范：

<blockquote>
  <ol style="list-style: none">
    <li>
      2.2.7 then must return a promise. <br/>
      <code>promise2 = promise1.then(onFulfilled, onRejected);</code>
      <ol style="list-style: none">
        <li>2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</li>
        <li>2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</li>
        <li>2.2.7.3 If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.</li>
        <li>2.2.7.4 If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1.</li>
      </ol>
    </li>
  </ol>
</blockquote>

先简单粗暴地用一个`promise`把之前的代码包裹起来

```typescript
export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
  onFulfilledCallbacks: OnFulfilledCallback[];
  onRejectedCallbacks: OnRejectedCallback[];

  // Promise A+规范对于构造函数这一块没有明确规定，这边按照常规的ES6+的用法来设计
  constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => any) {
    ...
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
+   return new SimplePromise((resolve, reject) => {
      // 将onFulfilled/onRejected改造为异步函数
      const asyncOnFulfilled = (value: unknown) => {
        setTimeout(() => {
          if (typeof onFulfilled === 'function') {
            onFulfilled(value);
          }
        });
      };
      const asyncOnRejected = (reason: unknown) => {
        setTimeout(() => {
          if (typeof onRejected === 'function') {
            onRejected(reason);
          }
        });
      };

      // 根据promise状态进行处理
      switch (this.state) {
        case SimplePromiseState.pending:
          this.onFulfilledCallbacks.push(asyncOnFulfilled);
          this.onRejectedCallbacks.push(asyncOnRejected);
          break;
        case SimplePromiseState.fulfilled:
          asyncOnFulfilled(this.value);
          break;
        case SimplePromiseState.rejected:
          asyncOnRejected(this.reason);
          break;
      }
+   });
  }
}
```

> 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).

根据 7.1，需要处理返回的`promise2`和`onFulfilled/onRejected`的返回值`x`的关系，具体如何处理在规范的下一部分中描述。（同样这里先留白处理）

```typescript
export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
  onFulfilledCallbacks: OnFulfilledCallback[];
  onRejectedCallbacks: OnRejectedCallback[];

  // Promise A+规范对于构造函数这一块没有明确规定，这边按照常规的ES6+的用法来设计
  constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => any) {
    ...
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
+   const nextPromise = new SimplePromise((resolve, reject) => {
      // 将onFulfilled/onRejected改造为异步函数
      const asyncOnFulfilled = (value: unknown) => {
        setTimeout(() => {
          if (typeof onFulfilled === 'function') {
+           const x = onFulfilled(value);
+           promiseResolveProcedure(nextPromise, x);
          }
        });
      };
      const asyncOnRejected = (reason: unknown) => {
        setTimeout(() => {
          if (typeof onRejected === 'function') {
+           const x = onRejected(reason);
+           promiseResolveProcedure(nextPromise, x);
          }
        });
      };

      // 根据promise状态进行处理
      switch (this.state) {
        case SimplePromiseState.pending:
          this.onFulfilledCallbacks.push(asyncOnFulfilled);
          this.onRejectedCallbacks.push(asyncOnRejected);
          break;
        case SimplePromiseState.fulfilled:
          asyncOnFulfilled(this.value);
          break;
        case SimplePromiseState.rejected:
          asyncOnRejected(this.reason);
          break;
      }
    });

+   return nextPromise;
  }
}

+ function promiseResolveProcedure(nextPromise: SimplePromise, x: unknown) {
+   // todo:
+ }
```

<blockquote>
  <ol style="list-style: none; padding: 0">
    <li>2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</li>
    <li>2.2.7.3 If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.</li>
    <li>2.2.7.4 If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1.</li>
  </ol>
</blockquote>

剩下的三条比较简单，规定了一些分支条件的处理，直接看实现吧。

```typescript
export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
  onFulfilledCallbacks: OnFulfilledCallback[];
  onRejectedCallbacks: OnRejectedCallback[];

  // Promise A+规范对于构造函数这一块没有明确规定，这边按照常规的ES6+的用法来设计
  constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => any) {
    ...
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
    const nextPromise = new SimplePromise((resolve, reject) => {
      // 将onFulfilled/onRejected改造为异步函数
      const asyncOnFulfilled = (value: unknown) => {
        setTimeout(() => {
+         try {
            if (typeof onFulfilled === 'function') {
              const x = onFulfilled(value);
              promiseResolveProcedure(nextPromise, x);
+           } else {
+             resolve(value);
+           }
+         } catch (e) {
+           reject(e);
+         }
        });
      };
      const asyncOnRejected = (reason: unknown) => {
        setTimeout(() => {
+         try {
            if (typeof onRejected === 'function') {
              const x = onRejected(reason);
              promiseResolveProcedure(nextPromise, x);
+           } else {
+             reject(reason);
+           }
+         } catch (e) {
+           reject(e);
+         }
        });
      };

      // 根据promise状态进行处理
      switch (this.state) {
        case SimplePromiseState.pending:
          this.onFulfilledCallbacks.push(asyncOnFulfilled);
          this.onRejectedCallbacks.push(asyncOnRejected);
          break;
        case SimplePromiseState.fulfilled:
          asyncOnFulfilled(this.value);
          break;
        case SimplePromiseState.rejected:
          asyncOnRejected(this.reason);
          break;
      }
    });

    return nextPromise;
  }
}

function promiseResolveProcedure(nextPromise: SimplePromise, x: unknown) {
  // todo:
}
```

OK，距离完成整个`promise`只剩下一个`promiseResolveProcedure`了 -.-

### 2.3 The Promise Resolution Procedure

<blockquote>
	<p>2.3 The Promise Resolution Procedure</p>
	<p> The promise resolution procedure is an abstract operation taking as input a promise and a value, which we denote as [[Resolve]](promise, x). If x is a thenable, it attempts to make promise adopt the state of x, under the assumption that x behaves at least somewhat like a promise. Otherwise, it fulfills promise with the value x.</p>
	<p>This treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/A+-compliant then method. It also allows Promises/A+ implementations to “assimilate” nonconformant implementations with reasonable then methods.</p>
	<p>To run [[Resolve]](promise, x), perform the following steps:</p>
	<ol style="list-style: none">
		<li>2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</li>
		<li>
			2.3.2 If x is a promise, adopt its state:
			<ol style="list-style: none">
				<li>2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.</li>
				<li>2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.</li>
				<li>2.3.2.3 If/when x is rejected, reject promise with the same reason.</li>
			</ol>
		</li>
		<li>
			2.3.3 Otherwise, if x is an object or function,
			<ol style="list-style: none">
				<li>2.3.3.1 Let then be x.then.</li>
				<li>2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</li>
				<li>
					2.3.3.3 If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:
					<ol style="list-style: none">
						<li>2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</li>
						<li>2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</li>
						<li>2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</li>
						<li>
							2.3.3.3.4 If calling then throws an exception e,
							<ol style="list-style: none">
								<li>2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</li>
								<li>2.3.3.3.4.2 Otherwise, reject promise with e as the reason.</li>
							</ol>
						</li>
					</ol>
				</li>
				<li>2.3.3.4 If then is not a function, fulfill promise with x.</li>
			</ol>
		</li>
		<li>2.3.4 If x is not an object or function, fulfill promise with x.</li>
	</ol>
</blockquote>

看完这部分规范，就发现需要把`nextPromise`构造函数中的`resolve/reject`传递进`promiseResolveProcedure`，或者把`resolve/reject`函数改为`promise`的一个成员属性。这两种写法都可以，这边就用了改动比较少的传递参数的形式

<pre class="highlight"><code class="hljs language-typescript">
+ function promiseResolveProcedure(
+   nextPromise: SimplePromise,
+   x: unknown,
+   nextPromiseResolve: ResolveFunc,
+   nextPromiseReject: RejectFunc
+ ) {
    // todo:
  }
</code></pre>

> 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.

第一条规范简单

```typescript
function promiseResolveProcedure(
  nextPromise: SimplePromise,
  x: unknown,
  nextPromiseResolve: ResolveFunc,
  nextPromiseReject: RejectFunc
) {
+ if (nextPromise === x) {
+   nextPromiseReject(new TypeError('Next promise and X cannot refer to the same object!'));
+   return;
+ }
}
```

<blockquote>
	2.3.2 If x is a promise, adopt its state:
	<ol style="list-style: none">
		<li>2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.</li>
		<li>2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.</li>
		<li>2.3.2.3 If/when x is rejected, reject promise with the same reason.</li>
	</ol>
</blockquote>

第二个规范也不难

<pre class="highlight"><code class="hljs language-typescript">
function promiseResolveProcedure(
  nextPromise: SimplePromise,
  x: unknown,
  nextPromiseResolve: ResolveFunc,
  nextPromiseReject: RejectFunc
) {
  if (nextPromise === x) {
    nextPromiseReject(new TypeError('Next promise and X cannot refer to the same object!'));
    return;
  }

+ if (x instanceof SimplePromise) {
+   switch (x.state) {
+     case SimplePromiseState.pending:
+       x.onFulfilledCallbacks.push(nextPromiseResolve);
+       x.onRejectedCallbacks.push(nextPromiseReject);
+       break;
+     case SimplePromiseState.fulfilled:
+       nextPromiseResolve(x.value);
+       break;
+     case SimplePromiseState.rejected:
+       nextPromiseReject(x.reason);
+       break;
+   }
+ }
}
</code></pre>

但是如果像上述这么去写，会有部分单元测试无法通过（别问我为什么知道的-.-），不过先不管它。

<blockquote>
	2.3.3 Otherwise, if x is an object or function,
	<ol style="list-style: none">
		<li>2.3.3.1 Let then be x.then.</li>
		<li>2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</li>
		<li>
			2.3.3.3 If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:
			<ol style="list-style: none">
				<li>2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</li>
				<li>2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</li>
				<li>2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</li>
				<li>
					2.3.3.3.4 If calling then throws an exception e,
					<ol style="list-style: none">
						<li>2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</li>
						<li>2.3.3.3.4.2 Otherwise, reject promise with e as the reason.</li>
					</ol>
				</li>
			</ol>
		</li>
		<li>2.3.3.4 If then is not a function, fulfill promise with x.</li>
	</ol>
</blockquote>

第三条是相对复杂的一条规范，其实核心思想就是尝试调用`x.then`来尽可能地取到最终的值，根据规范设置的分支条件一个个来，实现如下：

<pre class="highlight"><code class="hljs language-typescript">
function promiseResolveProcedure(
  nextPromise: SimplePromise,
  x: unknown,
  nextPromiseResolve: ResolveFunc,
  nextPromiseReject: RejectFunc
) {
  if (nextPromise === x) {
    nextPromiseReject(new TypeError('Next promise and X cannot refer to the same object!'));
    return;
  }

  if (x instanceof SimplePromise) {
    switch (x.state) {
      case SimplePromiseState.pending:
        x.onFulfilledCallbacks.push(nextPromiseResolve);
        x.onRejectedCallbacks.push(nextPromiseReject);
        break;
      case SimplePromiseState.fulfilled:
        nextPromiseResolve(x.value);
        break;
      case SimplePromiseState.rejected:
        nextPromiseReject(x.reason);
        break;
    }

    return;
  }

+ if (typeof x === 'object' || typeof x === 'function') { // 这个判断条件上其实还有一个坑 -.-
+   let called = false;
+
+   try {
+     // @ts-ignore
+     const then: unknown = x.then;
+
+     if (typeof then === 'function') {
+       then.call(
+         x,
+         (y: unknown) => {
+           if (!called) {
+             called = true;
+             promiseResolveProcedure(nextPromise, y, nextPromiseResolve, nextPromiseReject);
+           }
+         },
+         (e: unknown) => {
+           if (!called) {
+             called = true;
+             nextPromiseReject(e);
+           }
+         }
+       );
+     } else {
+       called = true;
+       nextPromiseResolve(x);
+     }
+   } catch (e) {
+     if (!called) {
+       called = true;
+       nextPromiseReject(e);
+     }
+   }
+ } else {
+   nextPromiseResolve(x);
+ }
}
</code></pre>

到这里为止，初版的一个`Promise A+`规范的实现就完成了，下面我们来进行测试～

# 单元测试

安装依赖

```
npm install promises-aplus-tests typescript --save-dev
```

新建一个`tsconfig.json`

```
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "outDir": "./compiled",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

新建一个适配器文件`index.ts`

```typescript
import { SimplePromise } from './simple-promise';

const resolved = (value: unknown) => {
  return new SimplePromise((resolve, reject) => {
    resolve(value);
  });
};

const rejected = (reason: unknown) => {
  return new SimplePromise((resolve, reject) => {
    reject(reason);
  });
};

const deferred = () => {
  const result: any = {};
  result.promise = new SimplePromise((resolve, reject) => {
    result.resolve = resolve;
    result.reject = reject;
  });

  return result;
};

export { resolved, rejected, deferred };
```

`package.json`中添加测试脚本

```
  {
    "script": {
      "test": "tsc && promises-aplus-tests compiled/index.js"
    }
  }
```

运行测试，如果所有的测试都通过，就可以说明符合 Promise A+规范

```
npm run test
```

然后...也就 122 个用例报错了嘛...orz

# Fix

先来处理比较简单的一个问题：

![null-error.png](/assets/images/blogs/js/2021-12-13-promiseA+/null-error.png)

orz，我记得在 JavaScript 中`typeof null === 'object'`是`true`的呀？不过类似这种问题算是 JavaScript 的糟粕吧，行吧，测试用例你说`null`不是`object`那就不是吧 -.-
这个问题很好改，在`promiseResolveProcedure`中对应判断的地方加一个判断

```typescript
function promiseResolveProcedure(
  nextPromise: SimplePromise,
  x: unknown,
  nextPromiseResolve: ResolveFunc,
  nextPromiseReject: RejectFunc
) {
  ...

+ if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    ...
  }
}
```

然后接着看剩下的 112 个报错...

![then-error.png](/assets/images/blogs/js/2021-12-13-promiseA+/then-error.png)

查看失败的用例和简单调试一下后，就发现，其实问题出现在`promiseResolveProcedure`处理`x`是`promise`类型的时候，成功的回调中如果`x.value`仍然是个符合`Thenable`接口的`object/promise`，没有去尝试进一步获取最终的值。对比一下规范中的下面两条：

<blockquote>
	2.3.2 If x is a promise, adopt its stat
	<ol style="list-style: none">
		<li>2.3.2.1 If/when x is fulfilled, fulfill promise with the same value.</li>
	</ol>
	2.3.3.3 If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:
	<ol style="list-style: none">
		<li>2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</li>
	</ol>
</blockquote>

当`x.then`是一个函数的时候，进入成功回调时，还是递归调用了`promiseResolveProcedure`去再次处理`y`。
然而对于`x`是一个`promise`进入成功回调时，却说明的有点模糊...根据单元测试的报错，其实就可以知道这边还是需要递归调用`promiseResolveProcedure`去处理`x.value`。（个人感觉，是规范在这一步的说明上不够明确，或者也有可能是我对规范的理解还不够 0.0）
明白了问题，代码改动起来就很简单了。

```typescript
function promiseResolveProcedure(
  nextPromise: SimplePromise,
  x: unknown,
  nextPromiseResolve: ResolveFunc,
  nextPromiseReject: RejectFunc
) {
  ...
  if (x instanceof SimplePromise) {
    switch (x.state) {
      case SimplePromiseState.pending:
+       x.onFulfilledCallbacks.push(() =>
+         promiseResolveProcedure(nextPromise, x.value, nextPromiseResolve, nextPromiseReject)
+       );
        x.onRejectedCallbacks.push(nextPromiseReject);
        break;
      case SimplePromiseState.fulfilled:
+       promiseResolveProcedure(nextPromise, x.value, nextPromiseResolve, nextPromiseReject);
        break;
      case SimplePromiseState.rejected:
        nextPromiseReject(x.reason);
        break;
    }

    return;
  }
  ...
}
```

最后贴上最终的代码

```typescript
// Thenable接口
export interface Thenable {
  then: Function;
}

// Promise的三种状态
enum SimplePromiseState {
  pending,
  fulfilled,
  rejected,
}

// 一些函数类型的定义
type ResolveFunc = (value: unknown) => void;
type RejectFunc = (reason: unknown) => void;
type OnFulfilledCallback = (value: unknown) => unknown;
type OnRejectedCallback = (reason: unknown) => unknown;

export class SimplePromise implements Thenable {
  state: SimplePromiseState;
  value: unknown;
  reason: unknown;
  onFulfilledCallbacks: OnFulfilledCallback[];
  onRejectedCallbacks: OnRejectedCallback[];

  // Promise A+规范对于构造函数这一块没有明确规定，这边按照常规的ES6+的用法来设计
  constructor(executor: (resolve: ResolveFunc, reject: RejectFunc) => any) {
    // 初始化内部状态为pending
    this.state = SimplePromiseState.pending;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value: unknown) => {
      if (this.state === SimplePromiseState.pending) {
        this.state = SimplePromiseState.fulfilled;
        this.value = value;
        this.onFulfilledCallbacks.forEach((callback) => callback(value));
      }
      // 这边如果resolve的时候promise不是pending状态其实可以报个错，但是不报也不影响
    };
    const reject = (reason: unknown) => {
      if (this.state === SimplePromiseState.pending) {
        this.state = SimplePromiseState.rejected;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((callback) => callback(reason));
      }
      // 这边如果reject的时候promise不是pending状态其实可以报个错，但是不报也不影响
    };

    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }

  then(onFulfilled?: OnFulfilledCallback, onRejected?: OnRejectedCallback): SimplePromise {
    const nextPromise = new SimplePromise((resolve, reject) => {
      // 将onFulfilled/onRejected改造为异步函数
      const asyncOnFulfilled = (value: unknown) => {
        setTimeout(() => {
          try {
            if (typeof onFulfilled === 'function') {
              const x = onFulfilled(value);
              promiseResolveProcedure(nextPromise, x, resolve, reject);
            } else {
              resolve(value);
            }
          } catch (e) {
            reject(e);
          }
        });
      };
      const asyncOnRejected = (reason: unknown) => {
        setTimeout(() => {
          try {
            if (typeof onRejected === 'function') {
              const x = onRejected(reason);
              promiseResolveProcedure(nextPromise, x, resolve, reject);
            } else {
              reject(reason);
            }
          } catch (e) {
            reject(e);
          }
        });
      };

      // 根据promise状态进行处理
      switch (this.state) {
        case SimplePromiseState.pending:
          this.onFulfilledCallbacks.push(asyncOnFulfilled);
          this.onRejectedCallbacks.push(asyncOnRejected);
          break;
        case SimplePromiseState.fulfilled:
          asyncOnFulfilled(this.value);
          break;
        case SimplePromiseState.rejected:
          asyncOnRejected(this.reason);
          break;
      }
    });

    return nextPromise;
  }
}

function promiseResolveProcedure(
  nextPromise: SimplePromise,
  x: unknown,
  nextPromiseResolve: ResolveFunc,
  nextPromiseReject: RejectFunc
) {
  if (nextPromise === x) {
    nextPromiseReject(new TypeError('Next promise and X cannot refer to the same object!'));
    return;
  }

  if (x instanceof SimplePromise) {
    switch (x.state) {
      case SimplePromiseState.pending:
        x.onFulfilledCallbacks.push(() =>
          promiseResolveProcedure(nextPromise, x.value, nextPromiseResolve, nextPromiseReject)
        );
        x.onRejectedCallbacks.push(nextPromiseReject);
        break;
      case SimplePromiseState.fulfilled:
        promiseResolveProcedure(nextPromise, x.value, nextPromiseResolve, nextPromiseReject);
        break;
      case SimplePromiseState.rejected:
        nextPromiseReject(x.reason);
        break;
    }

    return;
  }

  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let called = false;

    try {
      // @ts-ignore
      const then: unknown = x.then;

      if (typeof then === 'function') {
        then.call(
          x,
          (y: unknown) => {
            if (!called) {
              called = true;
              promiseResolveProcedure(nextPromise, y, nextPromiseResolve, nextPromiseReject);
            }
          },
          (e: unknown) => {
            if (!called) {
              called = true;
              nextPromiseReject(e);
            }
          }
        );
      } else {
        called = true;
        nextPromiseResolve(x);
      }
    } catch (e) {
      if (!called) {
        called = true;
        nextPromiseReject(e);
      }
    }
  } else {
    nextPromiseResolve(x);
  }
}
```

再跑一遍单元测试

![success.png](/assets/images/blogs/js/2021-12-13-promiseA+/success.png)

稳～

剩下的一些`Promise`的常规静态方法`Promise.resolve/Promise.reject/Promise.all/Promise.race`以及`catch`方法这边就不多阐述了，有了上述的基础，写起来非常简单...

# 后续的一些思考（瞎 BB）

前面不带脑子地按照`Promise A+`标准实现了一遍，现在需要回过头来思考`Promise A+`的一些设计。虽然对于当代前端工程师来说说，使用`Promise`已经像呼吸一样成为本能了，但`Promise`为什么会出现，以及为什么会被设计成这个样子，估计很多前端都没有仔细地去思考过。一般如果想要回答这样的问题，需要去参考`Promise`出现的背景以及它所期望去解决的问题。
首先`Promise`是 JavaScript 的一种异步调用机制。这一部分的一些前置知识`“event-loop”, “non-blocking”, “callback”, “asynchronous”, “single-threaded” and “concurrency”`，可以参考[这位小哥哥的演讲（需翻墙）](https://www.youtube.com/watch?v=8aGhZQkoFbQ)，讲得非常好。JavaScript 中最开始的回调机制，是通过调用 WebApis（DOM, AJAX, setTimeout 等），然后将回调函数作为参数传递进去，然后 WebApis 完成的时候将回调函数加入`callback queue`，等待当前执行栈中的代码执行完成后，取出`callback queue`中第一个回调函数执行。回调函数的机制是最原始的，但也是表达能力最强（最自由）的一种异步机制。但是一旦回调函数嵌套的多了以后，执行顺序的理解和可读性就成了噩梦（这种现象被叫做`Callbak Hell`）。比如下面的这一部分代码：

```javascript
app.get('/details', function (req, res) {
  var name = req.query.name;
  console.log(name);

  Scopus.find({ name: name }, { _id: 0, authorId: 1 }, function (err, result) {
    if (err) {
    } else {
      var searchResult = result[0]['authorId'];
      console.log(searchResult);
      var options = {
        url: 'https://api.elsevier.com/content/author/author_id/' + searchResult + '?apiKey',
        headers: { Accept: 'application/json' },
      };
      request(options, function (error, response, body) {
        if (error) {
          // Print the error if one occurred
          console.error('error in Authors :', error);

          // Print the response status code if a response was received
          console.log('statusCode:', response && response.statusCode);
          res.send('error');
        } else if (!error) {
          var jsonObj = JSON.parse(body);
          if (jsonObj['author-retrieval-response'] == undefined) {
            res.send('No details');
          } else {
            var reqData = jsonObj['author-retrieval-response'][0];
            var authprofile = reqData['author-profile'];
            var names = authprofile['preferred-name']['indexed-name'];
            console.log(names);
            var citation = reqData['coredata']['citation-count'];
            var query = { authorId: searchResult };

            Scopus.findOneAndUpdate(
              query,
              {
                name: names,
                citationCount: citation,
              },
              function (err, doc, res) {
                if (err) {
                  console.log('error');
                } else {
                  console.log('success');
                }
              }
            );
            res.render('details', { data: reqData });
          }
        }
      });
    }
  });
});
```

可以看到，回调函数层层嵌套，第一眼给人的印象就是 WTF，根本不想看了...
我们将异步的回调函数都`Promise`化看看...

```javascript
app.get('/details', function (req, res) {
  var name = req.query.name;
  console.log(name);

  Scopus.find({ name: name }, { _id: 0, authorId: 1 })
    .then(
      (result) => {
        var searchResult = result[0]['authorId'];
        console.log(searchResult);
        var options = {
          url: 'https://api.elsevier.com/content/author/author_id/' + searchResult + '?apiKey',
          headers: { Accept: 'application/json' },
        };
        return request(options);
      },
      (err) => {}
    )
    .then(
      (body) => {
        var jsonObj = JSON.parse(body);
        if (jsonObj['author-retrieval-response'] == undefined) {
          res.send('No details');
          return;
        } else {
          var reqData = jsonObj['author-retrieval-response'][0];
          res.render('details', { data: reqData });

          var authprofile = reqData['author-profile'];
          var names = authprofile['preferred-name']['indexed-name'];
          console.log(names);
          var citation = reqData['coredata']['citation-count'];
          var query = { authorId: searchResult };

          return Scopus.findOneAndUpdate(query, {
            name: names,
            citationCount: citation,
          });
        }
      },
      (error) => {
        // Print the error if one occurred
        console.error('error in Authors :', error);
        // Print the response status code if a response was received
        console.log('statusCode:', error.statusCode);
        res.send('error');
      }
    )
    .then(
      () => console.log('success'),
      (err) => console.log('error')
    );
});
```

可以很明显的看到，通过`Promise.then`的链式调用，成功地把嵌套的回调函数扁平化了，改成了`pipeline`式的写法，执行顺序也是从上而下符合阅读顺序，前一个函数的返回值就是下一个函数的参数，业务逻辑也实现了一定程度上的分离，比较接近于同步的写法，混乱的世界线得到了一定程度的收束（大误...）。
所以，这就是`Promise`期望去解决的一个问题，将回调地狱（`Callback Hell`）扁平化，提高代码的可读性和可维护性。从这样的一个目的去看，就不难理解`Promise A+`中的一些设计了。

- 比如为啥要有`promiseResolveProcedure`这样一个处理流程，就是为了扁平化嵌套的回调函数。`promiseResolveProcedure`会尽可能地去获取当前`onFulfilled/onRejected`函数最终的`value/reason`，如果返回的`value/reason`还是一个`Thenable`的`object/function`，它就会继续去尝试获取`Thenable`最终的`value/reason`而不是把这个`Thenable`直接返回。而如果还是回调函数的形式的话，一层`Thenable`就意味着一层嵌套...
- 比如为啥对`onFulfilled/onRejected`的返回值一视同仁都去走`promiseResolveProcedure`然后作为下一个`Promise`成功回调的参数，我是这样理解的，这样的设计是为了和`try/catch`逻辑保持一致。`try/catch`的逻辑是`throw`出来的`error`会沿着调用栈层层向上传递，直到有代码`catch`或者到顶。`onRejected`就有点像`catch`的部分，你可以选择对当前`Promise`异常的返回不做处理，那么它就会继续传递下去；也可以选择在当前这一个`Promise`中捕捉并处理掉，这样这个异常就应该在这一层被拦截掉而不是继续一路传递下去。所以实现了`onFulfilled/onRejected`后，`Promise`就认为你已经正确处理了这部分异步返回（无论正常/异常），这两个函数的返回值没有区别，都应该作为下一个`Promise`成功回调的参数。

# 其他

但是`Promise`也不是解决异步方案的银弹（软件工程没有银弹 0.0）。想要通过`Promise`将异步处理写成`pipeline`式的代码，需要满足

1. 需要等待前一个异步函数返回，再开始处理下一个异步函数，是一个串行的逻辑（虽然`Promise.all`，`Promise.race`能解决大部分并行的需求）
2. 只能接收上一个异步函数的返回值，无法“优雅“地获取之前异步函数的返回值（怎么就突然想到了祖孙组件通讯呢？？？）

后续 JavaScript 的异步处理方案进一步发展出了`generator`以及`async/await`，算是基本解决了第二个问题。
第一个问题的话，其实 95%（可能 99%？）的场景都没啥问题，也没看到关于这个问题特别好/优雅的解决方案（也有可能是我孤陋寡闻了），偶尔的特殊需求还是回归到`callback`吧...

关于`generator`和`async/await`的话，有空再写吧...
